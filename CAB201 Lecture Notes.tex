%!TEX program = xelatex
\documentclass{article}
\usepackage{LaTeX-Submodule/template}

% Additional packages & macros

% Header and footer
\newcommand{\unitName}{Programming Principals}
\newcommand{\unitTime}{Semester 1, 2022}
\newcommand{\unitCoordinator}{Dr Alan Woodley}
\newcommand{\documentAuthors}{\textsc{Tarang Janawalkar}}

\fancyhead[L]{\unitName}
\fancyhead[R]{\leftmark}
\fancyfoot[C]{\thepage}

% Copyright
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={4.0},
    imagewidth={5em},
    hyphenation={raggedright}
]{doclicense}

\date{}

\begin{document}
%
\begin{titlepage}
    \vspace*{\fill}
    \begin{center}
        \LARGE{\textbf{\unitName}} \\[0.1in]
        \normalsize{\unitTime} \\[0.2in]
        \normalsize\textit{\unitCoordinator} \\[0.2in]
        \documentAuthors
    \end{center}
    \vspace*{\fill}
    \doclicenseThis
    \thispagestyle{empty}
\end{titlepage}
\newpage
%
\tableofcontents
\newpage
%
\lstset{language=[Sharp]C}
\lstset{morekeywords={with,is,as}}
\section{Programming}
\begin{definition}
    Programming is the process of designing and building an executable
    computer program to accomplish a specific computing result or to
    perform a specific task.
\end{definition}
Programming involves:
\begin{enumerate}
    \item Analysis
    \item Design
    \item Implementation
    \item Testing
\end{enumerate}
\subsection{Analysis}
\begin{itemize}
    \item What is the problem?
    \item What data is involved --- input, output?
    \item What is the relationship between input and output?
    \item What other constraints?
\end{itemize}
\subsection{Design}
\begin{itemize}
    \item Specify modules that need to be created to implement the solution.
    \item Module --- group of closely related functions and data they need to do their job
    \item Which parts of the problem are closely related? They probably belong together in a module.
    \item How do modules fit together and communicate?
    \item How can I test each of these modules to be sure they behave as desired?
    \item How can I test the complete system to be sure it behaves as desired?
\end{itemize}
\subsection{Implementation}
\begin{itemize}
    \item Create working software to ``do'' each part of the design
    \item Select suitable algorithms and data structures to do each required item of functionality
    \item Write code to implement the algorithms and data structures
\end{itemize}
\subsection{Testing}
\begin{itemize}
    \item Before we write any code we should have a very clear idea how the program can be validated; usually that is done by testing
\end{itemize}
\section{Types and Expressions}
\subsection{Expressions}
\begin{definition}[Expressions]
    An expression is a combination of values, variables and operators.
    In interactive mode, an interpreter evaluates expressions and displays the result.
    However, in a script, we must first compile the program to an executable in order
    to perform any tasks.
\end{definition}
\begin{definition}[Type]
    The type of an expression is ``what kind of data'' the expression carries.
\end{definition}
\begin{definition}[Variables]
    Variables are a kind of expression which have an \textbf{identity} and a \textbf{value}.

    The \textbf{value} of a variable may change as a program runs, however in
    a statically typed language, the \textbf{type} of each variable is
    specified before it can be used, and \underline{never changes}.

    Variables can be declared as follows
    \begin{lstlisting}
TYPE_SPECIFIER IDENTIFIER;
TYPE_SPECIFIER IDENTIFIER = EXPRESSION;
    \end{lstlisting}
    In the first instance, we declare the type of the variable without initialising it.
    In the second case we declare and initialise the variable.
\end{definition}
\begin{definition}[Literal]
    The term \textit{literal} refers to the literal representation of a value.
    For example, when disambiguating between the variable \lstinline!dog!
    and the string \lstinline!"dog"! we would say the \emph{``variable dog''} % chktex 18
    vs.\ the \emph{``string literal dog''}.
\end{definition}
C\# identifiers must take the following into account
\begin{itemize}
    \item Identifiers can contain letters, digits and the underscore character (\lstinline!_!)
    \item Identifiers must begin with a letter
    \item Identifiers cannot contain whitespaces
    \item Identifiers are case sensitive (``\lstinline!Foo!'' and ``\lstinline!foo!'' are different variables) % chktex 38
    \item Reserved words such as C\# keywords cannot be used as identifiers
\end{itemize}
\subsection{Types}
There are 9 integer and 3 floating-point types in C\#, each with a different size and range. The minimum and maximum
values of any type can be determined using \lstinline!TYPE.MinValue! and \linebreak \lstinline!TYPE.MaxValue!.
\begin{table}[H]
    \centering
    \begin{tabular}{c c c}
        \toprule
        \textbf{C\# type}  & \textbf{Size} & \textbf{Range}                \\
        \midrule
        \lstinline!sbyte!  & 8 bit         & \(-2^7\) to \(2^7 - 1\)       \\
        \lstinline!byte!   & 8 bit         & \(0\) to \(2^8 - 1\)          \\
        \lstinline!short!  & 16 bit        & \(-2^{15}\) to \(2^{15} - 1\) \\
        \lstinline!ushort! & 16 bit        & \(0\) to \(2^{16} - 1\)       \\
        \lstinline!int!    & 32 bit        & \(-2^{31}\) to \(2^{31} - 1\) \\
        \lstinline!uint!   & 32 bit        & \(0\) to \(2^{32} - 1\)       \\
        \lstinline!long!   & 64 bit        & \(-2^{63}\) to \(2^{63} - 1\) \\
        \lstinline!ulong!  & 64 bit        & \(0\) to \(2^{64} - 1\)       \\
        \bottomrule
    \end{tabular}
    \caption{Integer types in C\#.}
    % \label{}
\end{table}
\begin{table}[H]
    \centering
    \begin{tabular}{c c c c}
        \toprule
        \textbf{C\# type}   & \textbf{Size} & \textbf{Range}                                              & \textbf{Precision}   \\
        \midrule
        \lstinline!float!   & 32 bit        & \(\pm 1.5 \times 10^{-45}\) to \(\pm 3.4 \times 10^{38}\)   & \sim 6 to 9 digits   \\
        \lstinline!double!  & 64 bit        & \(\pm 5.0 \times 10^{-324}\) to \(\pm 1.7 \times 10^{308}\) & \sim 15 to 17 digits \\
        \lstinline!decimal! & 128 bit       & \(\pm 1.0 \times 10^{-28}\) to \(7.9228 \times 10^{28}\)    & \sim 28 to 29 digits \\
        \bottomrule
    \end{tabular}
    \caption{Floating-point types in C\#.}
    % \label{}
\end{table}
\subsection{Type Conversion}
By default, C\texttt{\#} automatically assigns the \lstinline!int!, \lstinline!uint!,
\lstinline!long!, or \lstinline!ulong! type to any integer depending the size and sign
of the provided number. Any floating-point number is instantiated as a \lstinline!double!.
\begin{lstlisting}
$ (100).GetType()
[System.Int32]
$ (4294967295).GetType()    
[System.UInt32]
$ (-4294967295).GetType()
[System.Int64]
$ (100.0).GetType()
[System.Double]
\end{lstlisting}
To override this behaviour we can add a suffix to the number.
\begin{table}[H]
    \centering
    \begin{tabular}{c c}
        \toprule
        \textbf{Type}       & \textbf{Suffix}                                \\
        \midrule
        \lstinline!uint!    & \lstinline!u!                                  \\
        \lstinline!long!    & \lstinline!l!                                  \\
        \lstinline!ulong!   & \lstinline!u!, \lstinline!l! or \lstinline!ul! \\
        \midrule
        \lstinline!float!   & \lstinline!f!                                  \\
        \lstinline!double!  & \lstinline!d!                                  \\
        \lstinline!decimal! & \lstinline!m!                                  \\
        \bottomrule
    \end{tabular}
    \caption{Type suffixes for numeric types.}
    % \label{}
\end{table}
If a literal is prefixed with \lstinline!u!, its type is the first
of the following types in which its value can be represented:
\lstinline!uint!, \lstinline!ulong!.

Similarly, if a literal is prefixed with \lstinline!l!, its type is the first
of the following types in which its value can be represented:
\lstinline!long!, \lstinline!ulong!.

If the value of an integer is within the range of the destination type,
the value can be implicitly converted to the remaining integer types.
\subsubsection{Implicit Conversion}
Implicit conversions do not require any special syntax as the conversion
always succeeds and no data is lost.
The following diagram illustrates implicit conversions for numeric types.
The direction of the arrows indicate possible implicit conversions where
intermediate types can be skipped.
Note that all integer types can be converted to floating-point types.
\begin{figure}[H]
    \centering
    \includegraphics[height = 8cm, keepaspectratio = true]{figures/implicit_conversions.pdf}
    \caption{Numeric type implicit conversions in C\#.}
    % \label{}
\end{figure}
For example
\begin{lstlisting}
$ // 8 bit unsigned integer to 64 bit signed integer 
$ byte b = 32; Console.WriteLine($"{b} {b.GetType()}")
32 System.Byte
$ long l = b; Console.WriteLine($"{l} {l.GetType()}")
32 System.Int64
$ 
$ // 16 bit signed integer to double precision floating-point number
$ short s = 30000; Console.WriteLine($"{s} {s.GetType()}")
30000 System.Int16
$ double d = s; Console.WriteLine($"{d} {d.GetType()}")
30000 System.Double
\end{lstlisting}
\subsubsection{Explicit Conversion}
When a conversion cannot be made without risking losing information,
the compiler requires that we perform an explicit conversion using a \textbf{type cast}.
The syntax for a type cast is as follows
\begin{lstlisting}
(NEW_TYPE) EXPRESSION
\end{lstlisting}
For example
\begin{lstlisting}
$ // Decimal to single precision floating-point number
$ decimal pi = 3.14159265358979323m; Console.WriteLine($"{pi} {pi.GetType()}")
3.14159265358979323 System.Decimal
$ float fPi = (float) pi; Console.WriteLine($"{fPi} {fPi.GetType()}")
3.141593 System.Single

$ // 32 bit unsigned integer to 8 bit signed integer
$ uint u = 9876; Console.WriteLine($"{u} {u.GetType()}")
9876 System.UInt32
$ byte b = (byte) u; Console.WriteLine($"{b} {b.GetType()}")
148 System.Byte
\end{lstlisting}
In the final example, to understand what is happening in the explicit conversion,
we must look at the binary representation of the two integers.
\begin{lstlisting}
$ uint u = 9876; Console.WriteLine(Convert.ToString(u, 2).PadLeft(32, '0'))
00000000000000000010011010010100
$ byte b = (byte) u; Console.WriteLine(Convert.ToString(b, 2).PadLeft(8, '0'))
10010100
\end{lstlisting}
Notice that the value is determined by copying the 8 least significant bits
from the 32 bit unsigned integer.
\subsection{Operators}
The following table lists the C\texttt{\#} operators starting with the highest precedence to the lowest.
\begin{table}[H]
    \centering
    \begin{tabular}{>{\centering}p{0.45\linewidth} c}
        \toprule
        \textbf{Operators}                                                                                           & \textbf{Category}                 \\
        \midrule
        \lstinline!x.y!, \lstinline!f(x)!, \lstinline!a[i]!, \lstinline!x++!,
        \lstinline!x--!, \lstinline?x!?, \lstinline!x->y! and other keywords                                         & Primary                           \\
        \lstinline!+x!, \lstinline!-x!, \lstinline+!x+, \lstinline!~x!,
        \lstinline!++x!, \lstinline!--x!, \lstinline!^x!, \lstinline!(T)x!, \lstinline!await!,
        \lstinline!&x!, \lstinline!*x!, \lstinline!true!, \lstinline!false!                                          & Unary                             \\
        \lstinline!x..y!                                                                                             & Range                             \\
        \lstinline!switch!, \lstinline!with!                                                                         & ---                               \\
        \lstinline!x * y!, \lstinline!x / y!, \lstinline!x % y!                                                      & Multiplicative                    \\
        \lstinline!x + y!, \lstinline!x - y!                                                                         & Additive                          \\ % chktex 8
        \lstinline!x << y!, \lstinline!x >> y!                                                                       & Shift                             \\
        \lstinline!x < y!, \lstinline!x > y!, \lstinline!x <= y!, \lstinline!x >= y!, \lstinline!is!, \lstinline!as! & Relational and type-testing       \\
        \lstinline!x == y!, \lstinline?x != y?                                                                       & Equality                          \\ % chktex 26
        \lstinline!x & y!                                                                                            & Logical {\ttfamily{AND}}          \\
        \lstinline!x ^ y!                                                                                            & Logical {\ttfamily{XOR}}          \\
        \lstinline!x | y!                                                                                            & Logical {\ttfamily{OR}}           \\
        \lstinline!x && y!                                                                                           & Conditional {\ttfamily{AND}}      \\
        \lstinline!x || y!                                                                                           & Conditional {\ttfamily{OR}}       \\
        \lstinline!x ?? y!                                                                                           & Null-coalescing operator          \\ % chktex 26
        \lstinline!c ? t : f!                                                                                        & Conditional operator              \\ % chktex 26
        \lstinline!x = y!, \lstinline!=>! and shorthand assignments                                                  & Assignment and lambda declaration \\
        \bottomrule
    \end{tabular}
    \caption{Precedence of various operators in C\texttt{\#}.}
    % \label{}
\end{table}
In C\texttt{\#}, arithmetic operations behave as expected.
\begin{lstlisting}
$ 123 + 12
135
$ 123 - 12
111
$ 123 * 12
1476
$ 123 / 12
10
$ 123 % 12
3
\end{lstlisting}
Binary operators always convert the resulting data type to the data type of the
argument with the largest size in memory
(with a few exceptions when converting between floating-point types).
Each result in the above examples have the type \lstinline!System.Int32!.

Hence division between two 32 bit integers truncates any floating-point precision.
\begin{lstlisting}
$ 123 / 12
10
$ 123.0 / 12
10.25
$ 123 / 12.0
10.25
$ 123.0 / 12.0
10.25
\end{lstlisting}
Here the final three results are converted to the type \lstinline!System.Double!
using the reasoning given above.
\subsection{Characters}
A character type represents a \textbf{single} Unicode UTF-16 character.
Character objects can be implicitly converted to 16 bit unsigned integers and
support the comparison, equality, increment and \linebreak decrement operators.

A character is initialised using single quotation marks (\lstinline!'!). % chktex 38
\begin{lstlisting}
$ char c = 'A'; c
'A'
$ c.GetType()
[System.Char]
$ c++
'B'
$ (ushort) c
69
$ c == 69
true
\end{lstlisting}
\subsection{Strings}
A string is a sequential read-only collection of character objects.
A string is initialised using double quotation marks (\lstinline!"!). % chktex 18
\begin{lstlisting}
$ string s = "Hello, World!"; s
"Hello, World!"
$ s.GetType()
[System.String]
\end{lstlisting}
\subsubsection{String Indexing}
The characters in a string can be accessed by position (starting at 0).
\begin{lstlisting}
$ s[0]
'H'
$ s[s.Length - 1]
'!'
\end{lstlisting}
\subsubsection{Immutability}
In C\#, string objects are immutable meaning that the string cannot be modified in memory. If a new string is assigned
to this object, it will simply point to a new location in memory.
\begin{lstlisting}
$ string s = "String with tyop."; s
"String with tyop."
$ s[14] = 'p';
(1,1): error CS0200: Property or indexer 'string.this[int]' cannot be assigned 
to -- it is read only
$ s = "String without typo."
"String without typo."
\end{lstlisting}
\subsubsection{Escape Sequences}
To use special characters such as newlines, tabs, backslashes, or double quotation marks, we must
use an escape sequence.
\begin{lstlisting}
$ string s = "This is a quotation mark \".\nThis line appears on a new line."; s
"This is a quotation mark \".\nThis line appears on a new line."
\end{lstlisting}
Note that the string is evaluated as a string literal. To view this string verbatim, we must use
\lstinline!Console.WriteLine!.
\begin{lstlisting}
$ Console.WriteLine(s) 
This is a quotation mark ".
This line appears on a new line.
\end{lstlisting}
\subsubsection{Verbatim String Literals}
If a string contains many escape sequences we can use verbatim strings for convenience.
\begin{lstlisting}
$ string s = @"String with multiple escape sequences ""This is a quote"".
This line appears on a new line.";
$ Console.WriteLine(s)
String with multiple escape sequences "This is a quote".
This line appears on a new line.
\end{lstlisting}
\subsubsection{Format Strings}
To dynamically determine a string at runtime, we can use format strings.
There are two methods to create format strings: string interpolation and composite formatting.

String interpolation allows us to reference variable names directly inside a string.
Interpolated strings are identified by the dollar sign.
\begin{lstlisting}
$ int a = 40; int b = 13;
$ $"Given a = {a} and b = {b}, a + b = {a + b}"
"Given a = 40 and b = 13, a + b = 53"
\end{lstlisting}
Composite formatting uses placeholders for variables which must be provided in order of reference.
Here the same variable can be referenced many times in a string.
\begin{lstlisting}
$ int a = 40; int b = 13;
$ string.Format("Given a = {0} and b = {1}, a + b = {2}", a, b, a + b)
"Given a = 40 and b = 13, a + b = 53"
$ string.Format("a + b = {2} where a = {0} and b = {1}", a, b, a + b)
"a + b = 53 where a = 40 and b = 13"
$ string.Format("We can reference `a` twice, here {0} and here {0}", a)
"We can reference `a` twice, here 40 and here 40"
\end{lstlisting}
\subsubsection{Numeric to String Conversion}
Strings can be concatenated with numeric variables
\begin{lstlisting}
$ int a = 25;
$ "The temperature is " + a + " degrees."
"The temperature is 25 degrees."
\end{lstlisting}
As the \lstinline!+! operator is evaluated from left to right, the following string concatenation
will not evaluate the sum of 1, 2, and 3.
\begin{lstlisting}
$ "sum = " + 1 + 2 + 3
"sum = 123"
\end{lstlisting}
The \lstinline!ToString()! method can be accessed from all numeric types, with a
format specifier which indicates the number of precision to display.
\begin{lstlisting}
$ (1498).ToString("G3")
"1.5E+03"
$ (1498).ToString("F3")
"1498.000"
$ (1498).ToString("C2")
"$1,498.00"
\end{lstlisting}
These format specifiers can be applied directly in interpolated strings.
\begin{lstlisting}
$ int i = 1498;
$ $"{i:G3}, {i:F3}, {i:C2}"
"1.5E+03, 1498.000, $1,498.00"
\end{lstlisting}
We can also add specify padding in interpolated strings.
\begin{lstlisting}
$ decimal pi = 3.14159265358979323m;
$ $"Pi with left padding {pi, 10:F6}"
\end{lstlisting}
For more information see: \href{https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings}{\textit{Custom numeric format strings}}.
\subsubsection{String to Numeric Conversion}
We can convert a string to a number by calling the \lstinline!Parse! method found on numeric types,
or by using methods in the \lstinline!System.Convert! class.
\begin{lstlisting}
$ double.Parse("2.718281")
2.718281
$ Convert.ToDouble("2.718281")
2.718281
\end{lstlisting}
\section{Structured Programming}
Structured programming relies on three constructs: sequence, selection and iteration. 
These help us control the flow of our programs.
\subsection{Sequence}
In C\# we can group statements together inside a scope by using braces \lstinline!{ }!.
The statements inside this block are executed in order as a single instruction.
\begin{lstlisting}
$ int i = 5;
. {
.     i = 10;
.     Console.WriteLine(i);
. }
10
$ Console.WriteLine(i);
10
\end{lstlisting}
Here \lstinline!i! is accessed as an enclosing locally scoped variable.
\emph{This behaviour is akin to blocks defined in selection and iteration structures.}

Here is another example that utilises nested blocks and demonstrates access.
\begin{lstlisting}
$ // Global scope    
$ {
.     // Block 1     
.     int i = 5;  
.     Console.WriteLine(i);
.     {
.         // Block 2
.         i += 5;
.         Console.WriteLine(i);
.     }
.     // i = 10
. }
. Console.WriteLine(i);
5
10
(1,19): error CS0103: The name 'i' does not exist in the current context
\end{lstlisting}
In this example we see that the variable \lstinline!i! is local to block 1 and therefore accessible to block 2.

However, the converse is not true. \lstinline!i! cannot be accessed by its enclosing scope 
as local variables are destroyed when a block ends.

We also cannot declare a variable in a block that shares its name 
with another variable in its enclosing local scope.
\begin{lstlisting}
$ {
.     int i = 5;
.     {
.         int i = 5;
.     }   
. }
(4,13): error CS0136: A local or parameter named 'i' cannot be declared
in this scope because that name is used in an enclosing local scope to 
define a local or parameter
\end{lstlisting}
\subsection{Selection}
Selection allows us to choose from a range of different options.
\subsubsection{If Statements}
If statements have the following syntax.
\begin{lstlisting}
// Single statement
if (CONDITION) STATEMENT;
// Multiple statements
if (CONDITION)
{
    STATEMENTS
}
\end{lstlisting}
In both cases, \lstinline!CONDITION! is an expression that returns a Boolean value % chktex 13
when evaluated. If this value is \lstinline!true!, the subsequent statement(s) will 
be executed. Conversely, if the expression yields \lstinline!false!, the subsequent 
statement(s) will be ignored and control passes to the next statement after the \lstinline!if!
statement.

We can add an alternative statement if \lstinline!CONDITION! is \lstinline!false! using an \lstinline{else}
\lstinline!else! clause.
\begin{lstlisting}
// Single statement
if (CONDITION) STATEMENT_1 else STATEMENT_2;
// Multiple statements
if (CONDITION) 
{
    STATEMENTS_1
} else
{
    STATEMENTS_2;
}
\end{lstlisting}
This structure differs to the previous example slightly as either \lstinline!STATEMENT_1! or \lstinline!STATEMENT_2! 
will be executed. Again the decision depends on the Boolean value returned by the condition. 

The blocks in an \lstinline!if! statement can also allow us to nest any number of 
\lstinline!if! statements to create a more complex flow of control.
\begin{lstlisting}
if (CONDITION_1) if (CONDITION_2) STATEMENT_2 else STATEMENT_1;
// Written using braces
if (CONDITION_1) 
{
    if (CONDITION_2) 
    {
        STATEMENT_2
    }
} else 
{
    STATEMENT_1
}
\end{lstlisting}
Generally nested \lstinline!if! statements are difficult to read and should be avoided if possible.
An alternative to nested \lstinline!if! statements are cascading \lstinline!if! statements.
These statements allow us to provide controlled alternatives to an \lstinline!if-else! statement if the 
first condition returns \lstinline!false!.
\begin{lstlisting}
if (CONDITION_1) 
{
    STATEMENTS_1
} else if (CONDITION_2)
{
    STATEMENTS_2
} else if (CONDITION_3)
{
    STATEMENTS_3
} 
...
else {
    STATEMENTS_N
}
\end{lstlisting}
In this structure, any statement \(1<i<n\) will be executed if 
and only if all conditions before \(i\) yield \lstinline!false! and
\lstinline!CONDITION_I! yields \lstinline!true!. % chktex 13

The final statement \(n\) after the \lstinline!else! clause is executed
if all preceding conditions return \lstinline!false!.

Note that the \lstinline!else! clause may be omitted.
\subsubsection{Switch Statements}
A \lstinline!switch! statement is an alternative to cascading \lstinline!if!
statements and are another kind of multi-way branch.
\begin{lstlisting}
switch (EXPRESSION) 
{
    case CONSTANT_1:
        STATEMENTS_1;
        break;
    case CONSTANT_2:
        STATEMENTS_2;
        break;
    ...
    default:
        STATEMENTS_N;
        break;
}
\end{lstlisting}
In this structure, \lstinline!EXPRESSION! is any numeric or string expression, % chktex 13
and \lstinline!CONSTANT! is a literal of matching type. % chktex 13
This means that \lstinline!STATEMENTS_I! is executed if \lstinline!EXPRESSION == CONSTANT_I!. % chktex 13

The default branch behaves similarly to an \lstinline!else! clause and is executed if all 
none of the cases are satisfied.

Each branch must end with one of the following keywords depending on where the 
switch statement is defined: \lstinline!break!, \lstinline!return!, 
\lstinline!goto!, \lstinline!throw!, or \lstinline!continue!.
\subsection{Iteration}
Iterative constructs allow us to repeat statements zero, one, or many times,
without making multiple copies of the statement.
\end{document}
